import os
from pathlib import Path
from typing import Tuple, List

# Generated by ChatGPT because I had no time do to this, and was not particularly interesting
# for the purpose of my thesis

#Notes:
# - Coordinates: treated as Euclidean; output EDGE_WEIGHT_TYPE : EUC_2D.
#
# - Capacities (MDVRP): converter requires all depots share the same Q. If they don’t, it raises NotImplementedError (VRPLIB header has one CAPACITY scalar).
#
# - Vehicles per depot (MDVRP): Cordeau data doesn’t include it; we assign round-robin across depots so VEHICLES_DEPOT_SECTION has m lines. 
#
# - Service times / durations / periodic & time-window fields: ignored for these types (they aren’t used in standard CVRP/MDVRP VRPLIB consumed by PyVRP).
#
# - Validation: the function checks counts for the D Q block and node lines and raises CordeauFormatError if the file looks malformed.

class CordeauFormatError(ValueError):
    pass

def convert_cordeau_to_vrplib(input_path: str, output_path: str | None = None) -> str:
    """
    Convert a Cordeau-format instance (types 0=VRP/CVRP or 2=MDVRP) to a VRPLIB file
    compatible with PyVRP's reader.

    - For VRP/CVRP (type 0): assumes a single depot (index 0 in Cordeau).
    - For MDVRP (type 2): assumes t depots; requires all depots share the same capacity Q.
      Vehicles are assigned to depots evenly (round-robin) because Cordeau data does not
      specify a per-depot vehicle count.

    Parameters
    ----------
    input_path : str
        Path to the Cordeau file.
    output_path : str | None
        Where to write the VRPLIB file. If None, writes next to input with .mdvrp/.vrp.

    Returns
    -------
    str
        The path to the written VRPLIB file.

    Raises
    ------
    NotImplementedError
        If the instance type is not {0, 2}, or MDVRP depots have non-uniform Q.
    CordeauFormatError
        If the file does not conform to expected Cordeau layout.
    """
    p = Path(input_path)
    if not p.exists():
        raise FileNotFoundError(input_path)

    # --- read all non-empty, non-comment lines
    lines: List[str] = []
    with open(p, "r", encoding="utf-8") as f:
        for raw in f:
            s = raw.strip()
            if not s or s.startswith("#") or s.startswith("//"):
                continue
            lines.append(s)

    if not lines:
        raise CordeauFormatError("Empty file.")

    # --- header: "type m n t"
    try:
        head_tokens = lines[0].split()
        if len(head_tokens) != 4:
            raise ValueError
        type_, m, n, t = map(int, head_tokens)
    except Exception as e:
        raise CordeauFormatError(
            "First line must be: 'type m n t' with 4 integers."
        ) from e

    if type_ not in (0, 2):
        raise NotImplementedError(
            f"type={type_} not supported (only 0=VRP/CVRP and 2=MDVRP)."
        )

    # --- next t lines: "D Q"
    if len(lines) < 1 + t:
        raise CordeauFormatError("Not enough lines for the D Q block.")
    DQ: List[Tuple[float, int]] = []
    for idx in range(1, 1 + t):
        toks = lines[idx].split()
        if len(toks) < 2:
            raise CordeauFormatError(f"Expected 'D Q' on line {idx+1}.")
        D = float(toks[0]); Q = int(float(toks[1]))
        DQ.append((D, Q))

    # --- node lines:
    remain = lines[1 + t:]  # everything after DQ
    if type_ == 0:
        # VRP/CVRP: lines go 0..n (depot + n customers)
        expected = n + 1
        if len(remain) < expected:
            raise CordeauFormatError(f"Expected at least {expected} node lines, got {len(remain)}.")
        node_lines = remain[:expected]
        # i x y d q ...
        # first node is depot (index 0 in Cordeau)
        depot_raw = node_lines[0].split()
        if len(depot_raw) < 5:
            raise CordeauFormatError("Depot line must contain at least 'i x y d q'.")
        # collect customers
        cust_raws = [ln.split() for ln in node_lines[1:]]
        for cr in cust_raws:
            if len(cr) < 5:
                raise CordeauFormatError("Customer line must contain at least 'i x y d q'.")

        # Build VRPLIB blocks
        Q_unique = DQ[0][1]  # single depot/day in VRP
        vehicles = m
        # VRPLIB node order: put depot as 1, then customers 2..n+1
        dep_x, dep_y = float(depot_raw[1]), float(depot_raw[2])
        nodes = [(1, dep_x, dep_y)]
        demands = [(1, 0)]
        # customers: renumber 2..n+1
        for k, cr in enumerate(cust_raws, start=2):
            x, y = float(cr[1]), float(cr[2])
            q = int(float(cr[4]))
            nodes.append((k, x, y))
            demands.append((k, q))

        dep_ids = [1]
        veh_depot = [1] * vehicles  # all vehicles at the single depot

        name = p.stem
        out_type = "CVRP"
        dimension = 1 + n
        capacity = Q_unique

    elif type_ == 2:
        # MDVRP: lines go 1..n+t, last t entries are depots
        expected = n + t
        if len(remain) < expected:
            raise CordeauFormatError(f"Expected at least {expected} node lines, got {len(remain)}.")
        node_lines = remain[:expected]
        node_tokens = [ln.split() for ln in node_lines]
        for tok in node_tokens:
            if len(tok) < 5:
                raise CordeauFormatError("Each node line must contain at least 'i x y d q'.")

        # Split customers vs depots
        cust_tokens = node_tokens[:n]          # first n are customers
        depot_tokens = node_tokens[n:n+t]      # last t are depots

        # capacity consistency across depots (required here)
        Qs = {Q for (_, Q) in DQ}
        if len(Qs) != 1:
            raise NotImplementedError(
                f"Unequal depot capacities found: {sorted(Qs)}. "
                "This converter currently supports a single CAPACITY value."
            )
        capacity = next(iter(Qs))
        vehicles = m

        # Node order in VRPLIB: put depots first (1..t), then customers (t+1..t+n)
        nodes = []
        demands = []
        dep_ids = []
        for k, dt in enumerate(depot_tokens, start=1):
            x, y = float(dt[1]), float(dt[2])
            nodes.append((k, x, y))
            demands.append((k, 0))
            dep_ids.append(k)

        for j, ct in enumerate(cust_tokens, start=t+1):
            x, y = float(ct[1]), float(ct[2])
            q = int(float(ct[4]))
            nodes.append((j, x, y))
            demands.append((j, q))

        # Assign vehicles to depots evenly (round-robin)
        veh_depot = []
        for vid in range(vehicles):
            veh_depot.append(dep_ids[vid % t])

        name = p.stem
        out_type = "MDVRP"
        dimension = n + t

    # --- Compose VRPLIB text
    # Default to EUC_2D for Cordeau coordinates.
    vrplib_lines = []
    vrplib_lines.append(f"NAME : {name}")
    vrplib_lines.append(f"TYPE : {out_type}")
    vrplib_lines.append(f"DIMENSION : {dimension}")
    vrplib_lines.append(f"VEHICLES : {vehicles}")
    vrplib_lines.append(f"CAPACITY : {capacity}")
    vrplib_lines.append("EDGE_WEIGHT_TYPE : EUC_2D")

    vrplib_lines.append("NODE_COORD_SECTION")
    for idx, x, y in nodes:
        # Cast to ints if they look integral; VRPLIB is fine with ints
        ix = int(x) if abs(x - int(x)) < 1e-9 else x
        iy = int(y) if abs(y - int(y)) < 1e-9 else y
        vrplib_lines.append(f"{idx} {ix} {iy}")

    vrplib_lines.append("DEMAND_SECTION")
    for idx, q in demands:
        vrplib_lines.append(f"{idx} {int(q)}")

    vrplib_lines.append("DEPOT_SECTION")
    for dep in dep_ids:
        vrplib_lines.append(str(dep))
    vrplib_lines.append("-1")

    # Always include VEHICLES_DEPOT_SECTION to be explicit for PyVRP MDVRP.
    vrplib_lines.append("VEHICLES_DEPOT_SECTION")
    for dep in veh_depot:
        vrplib_lines.append(str(dep))

    vrplib_lines.append("EOF")
    text = "\n".join(vrplib_lines) + "\n"

    # --- Write file
    if output_path is None:
        # Use .vrp for single depot, .mdvrp for multi-depot for clarity
        ext = ".vrp" if out_type == "CVRP" else ".mdvrp"
        output_path = str(p.with_suffix(ext))
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(text)
    return output_path

