import os
from pathlib import Path
from typing import Tuple, List

# Generated by ChatGPT because I had no time do to this, and was not particularly interesting
# for the purpose of my thesis

#Notes:
# - Coordinates: treated as Euclidean; output EDGE_WEIGHT_TYPE : EUC_2D.
#
# - Capacities (MDVRP): converter requires all depots share the same Q. If they don’t, it raises NotImplementedError (VRPLIB header has one CAPACITY scalar).
#
# - Vehicles per depot (MDVRP): Cordeau data doesn’t include it; we assign round-robin across depots so VEHICLES_DEPOT_SECTION has m lines. 
#
# - Service times / durations / periodic & time-window fields: ignored for these types (they aren’t used in standard CVRP/MDVRP VRPLIB consumed by PyVRP).
#
# - Validation: the function checks counts for the D Q block and node lines and raises CordeauFormatError if the file looks malformed.

class CordeauFormatError(ValueError):
    pass

def convert_cordeau_to_vrplib(input_path: str, output_path: str | None = None) -> str:
    """
    Convert a Cordeau-format instance (types 0=VRP/CVRP or 2=MDVRP) to a VRPLIB file
    compatible with PyVRP's reader.

    - For VRP/CVRP (type 0): assumes a single depot (index 0 in Cordeau).
    - For MDVRP (type 2): assumes t depots; requires all depots share the same capacity Q.
      Vehicles are assigned to depots evenly (round-robin) because Cordeau data does not
      specify a per-depot vehicle count.

    Parameters
    ----------
    input_path : str
        Path to the Cordeau file.
    output_path : str | None
        Where to write the VRPLIB file. If None, writes next to input with .mdvrp/.vrp.

    Returns
    -------
    str
        The path to the written VRPLIB file.

    Raises
    ------
    NotImplementedError
        If the instance type is not {0, 2}, or MDVRP depots have non-uniform Q.
    CordeauFormatError
        If the file does not conform to expected Cordeau layout.
    """
    p = Path(input_path)
    if not p.exists():
        raise FileNotFoundError(input_path)

    # --- read all non-empty, non-comment lines
    lines: List[str] = []
    with open(p, "r", encoding="utf-8") as f:
        for raw in f:
            s = raw.strip()
            if not s or s.startswith("#") or s.startswith("//"):
                continue
            lines.append(s)

    if not lines:
        raise CordeauFormatError("Empty file.")

    # --- header: "type m n t"
    try:
        head_tokens = lines[0].split()
        if len(head_tokens) != 4:
            raise ValueError
        type_, m, n, t = map(int, head_tokens)
    except Exception as e:
        raise CordeauFormatError(
            "First line must be: 'type m n t' with 4 integers."
        ) from e

    if type_ not in (0, 2):
        raise NotImplementedError(
            f"type={type_} not supported (only 0=VRP/CVRP and 2=MDVRP)."
        )

    # --- next t lines: "D Q"
    if len(lines) < 1 + t:
        raise CordeauFormatError("Not enough lines for the D Q block.")
    DQ: List[Tuple[float, int]] = []
    for idx in range(1, 1 + t):
        toks = lines[idx].split()
        if len(toks) < 2:
            raise CordeauFormatError(f"Expected 'D Q' on line {idx+1}.")
        D = float(toks[0]); Q = int(float(toks[1]))
        DQ.append((D, Q))

    # --- node lines:
    remain = lines[1 + t:]  # everything after DQ
    if type_ == 0:
        # VRP/CVRP: lines go 0..n (depot + n customers)
        expected = n + 1
        if len(remain) < expected:
            raise CordeauFormatError(f"Expected at least {expected} node lines, got {len(remain)}.")
        node_lines = remain[:expected]
        # i x y d q ...
        # first node is depot (index 0 in Cordeau)
        depot_raw = node_lines[0].split()
        if len(depot_raw) < 5:
            raise CordeauFormatError("Depot line must contain at least 'i x y d q'.")
        # collect customers
        cust_raws = [ln.split() for ln in node_lines[1:]]
        for cr in cust_raws:
            if len(cr) < 5:
                raise CordeauFormatError("Customer line must contain at least 'i x y d q'.")

        # Build VRPLIB blocks
        Q_unique = DQ[0][1]  # single depot/day in VRP
        vehicles = m
        # VRPLIB node order: put depot as 1, then customers 2..n+1
        dep_x, dep_y = float(depot_raw[1]), float(depot_raw[2])
        nodes = [(1, dep_x, dep_y)]
        demands = [(1, 0)]
        # customers: renumber 2..n+1
        for k, cr in enumerate(cust_raws, start=2):
            x, y = float(cr[1]), float(cr[2])
            q = int(float(cr[4]))
            nodes.append((k, x, y))
            demands.append((k, q))

        dep_ids = [1]
        veh_depot = [1] * vehicles  # all vehicles at the single depot

        name = p.stem
        out_type = "CVRP"
        dimension = 1 + n
        capacity = Q_unique

    elif type_ == 2:
        # MDVRP: lines go 1..n+t, last t entries are depots
        expected = n + t
        if len(remain) < expected:
            raise CordeauFormatError(f"Expected at least {expected} node lines, got {len(remain)}.")
        node_lines = remain[:expected]
        node_tokens = [ln.split() for ln in node_lines]
        for tok in node_tokens:
            if len(tok) < 5:
                raise CordeauFormatError("Each node line must contain at least 'i x y d q'.")

        # Split customers vs depots
        cust_tokens = node_tokens[:n]          # first n are customers
        depot_tokens = node_tokens[n:n+t]      # last t are depots

        # capacity consistency across depots (required here)
        Qs = {Q for (_, Q) in DQ}
        if len(Qs) != 1:
            raise NotImplementedError(
                f"Unequal depot capacities found: {sorted(Qs)}. "
                "This converter currently supports a single CAPACITY value."
            )
        capacity = next(iter(Qs))
        vehicles = m

        # Node order in VRPLIB: put depots first (1..t), then customers (t+1..t+n)
        nodes = []
        demands = []
        dep_ids = []
        for k, dt in enumerate(depot_tokens, start=1):
            x, y = float(dt[1]), float(dt[2])
            nodes.append((k, x, y))
            demands.append((k, 0))
            dep_ids.append(k)

        for j, ct in enumerate(cust_tokens, start=t+1):
            x, y = float(ct[1]), float(ct[2])
            q = int(float(ct[4]))
            nodes.append((j, x, y))
            demands.append((j, q))

        # Assign vehicles to depots evenly (round-robin)
        veh_depot = []
        for vid in range(vehicles):
            veh_depot.append(dep_ids[vid % t])

        name = p.stem
        out_type = "MDVRP"
        dimension = n + t

    # --- Compose VRPLIB text
    # Default to EUC_2D for Cordeau coordinates.
    vrplib_lines = []
    vrplib_lines.append(f"NAME : {name}")
    vrplib_lines.append(f"TYPE : {out_type}")
    vrplib_lines.append(f"DIMENSION : {dimension}")
    vrplib_lines.append(f"VEHICLES : {vehicles}")
    vrplib_lines.append(f"CAPACITY : {capacity}")
    vrplib_lines.append("EDGE_WEIGHT_TYPE : EUC_2D")

    vrplib_lines.append("NODE_COORD_SECTION")
    for idx, x, y in nodes:
        # Cast to ints if they look integral; VRPLIB is fine with ints
        ix = int(x) if abs(x - int(x)) < 1e-9 else x
        iy = int(y) if abs(y - int(y)) < 1e-9 else y
        vrplib_lines.append(f"{idx} {ix} {iy}")

    vrplib_lines.append("DEMAND_SECTION")
    for idx, q in demands:
        vrplib_lines.append(f"{idx} {int(q)}")

    vrplib_lines.append("DEPOT_SECTION")
    for dep in dep_ids:
        vrplib_lines.append(str(dep))
    vrplib_lines.append("-1")

    # Always include VEHICLES_DEPOT_SECTION to be explicit for PyVRP MDVRP.
    vrplib_lines.append("VEHICLES_DEPOT_SECTION")
    for dep in veh_depot:
        vrplib_lines.append(str(dep))

    vrplib_lines.append("EOF")
    text = "\n".join(vrplib_lines) + "\n"

    # --- Write file
    if output_path is None:
        # Use .vrp for single depot, .mdvrp for multi-depot for clarity
        ext = ".vrp" if out_type == "CVRP" else ".mdvrp"
        output_path = str(p.with_suffix(ext))
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(text)
    return output_path



def convert_vrplib_to_cordeau(input_path: str, output_path: str | None = None) -> str:
    """
    Convert a VRPLIB instance (CVRP or MDVRP) into a Cordeau-style text file
    that is round-trip compatible with convert_cordeau_to_vrplib() above.

    VRPLIB assumptions (as produced/consumed by PyVRP and this module):
      - TYPE: "CVRP" (single depot) or "MDVRP" (multi depot).
      - DEPOT_SECTION lists depot indices (ending with -1).
      - DEMAND_SECTION provides integer demands; depots have demand 0.
      - CAPACITY is a single scalar (uniform Q for all depots).
      - VEHICLES present (integer).
      - NODE_COORD_SECTION present with 2D coordinates.
      - VEHICLES_DEPOT_SECTION is ignored here (Cordeau does not store per-depot counts).

    Cordeau output (matching this module's parser):
      - First line: "type m n t" where type=0 for CVRP, 2 for MDVRP.
      - Next t lines: "D Q" with D=0 and Q=CAPACITY for each depot.
      - Node lines:
          * type=0 (CVRP): depot first (index 0), then n customers 1..n
          * type=2 (MDVRP): n customers 1..n first, then t depots (n+1 .. n+t)
        Each node line: "i x y d q" with d=0 and q= demand (0 at depots).

    Returns the path to the written Cordeau file.
    """
    p = Path(input_path)
    if not p.exists():
        raise FileNotFoundError(input_path)

    # --- read raw lines and collect sections
    with open(p, "r", encoding="utf-8") as f:
        raw = [ln.rstrip("\n") for ln in f]

    # Simple helper to find section indices
    def find_line(startswith: str) -> int | None:
        for i, ln in enumerate(raw):
            if ln.strip().upper().startswith(startswith):
                return i
        return None

    # Header fields
    def read_scalar_after(prefix: str, cast=int) -> int | float | str:
        idx = find_line(prefix)
        if idx is None:
            raise CordeauFormatError(f"Missing header line starting with '{prefix}'.")
        try:
            return cast(raw[idx].split(":")[1].strip())
        except Exception as e:
            raise CordeauFormatError(f"Malformed header: '{raw[idx]}'") from e

    name = None
    name_idx = find_line("NAME")
    if name_idx is not None:
        try:
            name = raw[name_idx].split(":")[1].strip()
        except Exception:
            name = p.stem
    else:
        name = p.stem

    type_line = find_line("TYPE")
    if type_line is None:
        raise CordeauFormatError("Missing TYPE line.")
    type_token = raw[type_line].split(":")[1].strip().upper()
    if type_token not in ("CVRP", "MDVRP"):
        raise NotImplementedError(f"TYPE '{type_token}' not supported (only CVRP/MDVRP).")

    dimension = int(read_scalar_after("DIMENSION"))
    vehicles = int(read_scalar_after("VEHICLES"))
    capacity = int(read_scalar_after("CAPACITY"))
    # EDGE_WEIGHT_TYPE is ignored; coordinates are taken as-is.

    # --- Parse DEPOT_SECTION
    dep_idx = find_line("DEPOT_SECTION")
    if dep_idx is None:
        raise CordeauFormatError("Missing DEPOT_SECTION.")
    depots: list[int] = []
    i = dep_idx + 1
    while i < len(raw):
        s = raw[i].strip()
        if not s:
            i += 1
            continue
        if s == "EOF":
            break
        try:
            val = int(s.split()[0])
        except Exception:
            break
        if val == -1:
            break
        depots.append(val)
        i += 1
    if not depots:
        raise CordeauFormatError("DEPOT_SECTION contains no depots.")
    t = len(depots)

    # --- Parse NODE_COORD_SECTION
    nc_idx = find_line("NODE_COORD_SECTION")
    if nc_idx is None:
        raise CordeauFormatError("Missing NODE_COORD_SECTION.")
    coords: dict[int, tuple[float, float]] = {}
    j = nc_idx + 1
    while j < len(raw):
        s = raw[j].strip()
        if not s or s.upper().startswith(("DEMAND_SECTION", "DEPOT_SECTION", "EOF", "VEHICLES_DEPOT_SECTION")):
            break
        toks = s.split()
        if len(toks) < 3:
            raise CordeauFormatError(f"Malformed NODE_COORD_SECTION line: '{s}'")
        idx = int(float(toks[0]))
        x = float(toks[1]); y = float(toks[2])
        coords[idx] = (x, y)
        j += 1

    # --- Parse DEMAND_SECTION
    dem_idx = find_line("DEMAND_SECTION")
    if dem_idx is None:
        raise CordeauFormatError("Missing DEMAND_SECTION.")
    demand: dict[int, int] = {}
    k = dem_idx + 1
    while k < len(raw):
        s = raw[k].strip()
        if not s or s.upper().startswith(("NODE_COORD_SECTION", "DEPOT_SECTION", "EOF", "VEHICLES_DEPOT_SECTION")):
            break
        toks = s.split()
        if len(toks) < 2:
            raise CordeauFormatError(f"Malformed DEMAND_SECTION line: '{s}'")
        idx = int(float(toks[0])); q = int(float(toks[1]))
        demand[idx] = q
        k += 1

    # --- Basic validation
    all_indices = set(coords.keys())
    if set(demand.keys()) != all_indices:
        missing_d = sorted(all_indices - set(demand.keys()))
        missing_c = sorted(set(demand.keys()) - all_indices)
        raise CordeauFormatError(f"Mismatch between coordinates and demands. "
                                 f"Missing demands for: {missing_d}; stray demand indices: {missing_c}")

    # Identify depots/customers as per DEPOT_SECTION
    depot_set = set(depots)
    for d in depot_set:
        if d not in all_indices:
            raise CordeauFormatError(f"Depot index {d} not present in NODE_COORD_SECTION.")
        if demand.get(d, 0) != 0:
            raise CordeauFormatError(f"Depot index {d} has non-zero demand ({demand[d]}).")

    # Customers are all nodes not in depots
    customer_ids = sorted(idx for idx in all_indices if idx not in depot_set)
    n = len(customer_ids)

    # Sanity for dimension
    if dimension != len(all_indices):
        # Not fatal, but warn the user by raising (keeps behavior strict like the forward converter)
        raise CordeauFormatError(f"DIMENSION={dimension} does not match number of nodes={len(all_indices)}.")

    # --- Compose Cordeau text (round-trip compatible with the forward converter)
    if type_token == "CVRP":
        if t != 1:
            # CVRP must have exactly one depot here
            raise CordeauFormatError(f"CVRP expects exactly one depot, found t={t}.")
        type_ = 0
        # Header: type m n t
        header = f"{type_} {vehicles} {n} {t}"

        # D Q block: single line; D=0
        dq_lines = [f"0 {capacity}"]

        # Node lines: depot first (index 0), then customers 1..n
        # We map VRPLIB depot id -> (0) and customers -> 1..n in the order they appear when sorted by id.
        depot_id_vrplib = depots[0]
        dep_x, dep_y = coords[depot_id_vrplib]
        nodes_lines = [f"0 {dep_x} {dep_y} 0 0"]

        # Preserve original order of customers as they appear when sorting by index ascending,
        # which matches typical VRPLIB authoring and is stable under our forward converter.
        for new_i, old_idx in enumerate(sorted(customer_ids), start=1):
            x, y = coords[old_idx]
            q = demand[old_idx]
            nodes_lines.append(f"{new_i} {x} {y} 0 {q}")

        lines_out = [header, *dq_lines, *nodes_lines]

    else:  # MDVRP
        type_ = 2
        # Require uniform capacity (one CAPACITY scalar already implies this).
        # Header: type m n t
        header = f"{type_} {vehicles} {n} {t}"

        # D Q block: t lines; use D=0, Q=capacity for each depot.
        dq_lines = [f"0 {capacity}" for _ in range(t)]

        # Node lines: first n customers -> indices 1..n, then t depots -> indices n+1..n+t
        # Customers: use ascending VRPLIB indices not in depots
        nodes_lines = []
        for new_i, old_idx in enumerate(sorted(customer_ids), start=1):
            x, y = coords[old_idx]; q = demand[old_idx]
            nodes_lines.append(f"{new_i} {x} {y} 0 {q}")

        # Depots at the end in the order provided by DEPOT_SECTION (preserve user intent)
        for offset, old_idx in enumerate(depots, start=1):
            x, y = coords[old_idx]
            nodes_lines.append(f"{n + offset} {x} {y} 0 0")

        lines_out = [header, *dq_lines, *nodes_lines]

    # --- Write file
    if output_path is None:
        output_path = str(p.with_suffix(".cordeau.txt"))
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines_out) + "\n")

    return output_path

